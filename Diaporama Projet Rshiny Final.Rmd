---
title: "Logiciel de statistiques RShiny"
output:
  flexdashboard::flex_dashboard:
    orientation: rows
    vertical_layout: fill
    self_contained : TRUE
date: "2025-01-08"
runtime: shiny
---
Introduction
==================

ATTENTION : 1:test name qu'est ce que c'est ? 
ENLEVER certaine boucle if : 1 programme de NORAMLITE...se BALLADE!
Attention mots anglais sur interface graphique !!! 


Cette application va permettre de choisir automatiquement un test statistique, parmi les statistiques paramétriques et semi-paramétriques , offrant une analyse approfondie, et surtout automatique.

Automatique car aucune action de l'utilisateur n'est à effectuer, excepté l'importation et la sélection de variables.

Utilisation de Shiny et Flexdashboard: avantages et désavantages
==================
Rshiny est open source.Il permet notamment de pouvoir exécuter des calculs scientifiques tout en laissant à l'utilisateur la possibilité de modifier de nombreux paramètres. Ainsi, l'avantage de l'utilisation de Shiny dans ce code est qu'il permet d'adapter les tests statistiques à toute base de données. 
De plus, il permet l'utilisation d'une interface conviviale. 

Un des désavantages de Shiny est notamment l'obligation de devoir écrire le code principalement en deux parties distinctes, autant que l'utilisation certes du code R, en majorité, mais avec de nombreuses nouvelles commandes. Par exemple, Renderplot va remplacer le plot de R afin de pouvoir afficher les résultats des graphiques. De façon général, toute commande commençant par Render.

Une autre difficulté réside donc dans l'obligation de devoir coder dans une application, que ce soit l'UI ou le Server, ce qui implique une syntaxe particulière, avec beaucoup plus de virgules, ou d'indentation à effectuer.Ici, la fonction server fait plus de 400 lignes, ce qui complique tout de même fortement l'écriture du code,; d'autant plus que RShiny est sensible à toute casse.  

Enfin, avec Flexdashboard, on peut afficher les résultats de Rshiny tout en les commentant, dans un fichier Rmarkdown, et cela permet donc de facilement présenter au final le travail effectué sous R shiny, en format htlm.De plus, d'autres package de présentation ont été testés, mais ils n'offrent pas l'implémentation officiellement sous RShiny. 

Elle repose également sur le support de Shiny par Rmarkdown, d'où l'ajout dans le YAML du runtime:Shiny, ce qui permet donc de faire tourner également sous Rmarkdown du code Shiny, par la fonction Shinyapp. 

Ensuite, le code repose également sur des boucles if-else , assez longues ; bien que la fonction switch() a été utilisée à un moment donné afin de simplifier le code. Toutefois, cela n'était pas possible pour les boucles "if-else", étant donné que la boucle peut très bien s'arrêter uniquement à la 1ere boucle afin d'afficher le résultat ou le texte du programme de sélection automatique. 

Structure algorithmique de l'application {data-orientation=rows}
==================

L'application suit la logique suivante : 
I.Utilisateurs :<br>
1.Proposition d'importer un fichier en différents formats : excel, csv...<br>
2.Choix dans 1 menu déroulant des variables clés X et Y 

II.Partie automatisée (comme demandé)
I.Typologie 
1. L'hypothèse de normalité est vérifiée ou non.<br> 
2. Détermination du type de Y : binaire, multinomial, quantitatif<br>
3. Détermination du type de X : numérique,dichotomique, catégoriel. <br>
II.Déterminations
1.Détermination notamment du meilleur test statistique suivant les types.
2. Mise en place du lien entre les packages  de calculs de test et la typologie. 
III. Partie UI (obligatoirement placée en 1er dans le code)
1.Mettre en place la sélection de variables avec Introbox (shinyjs)
2.Mettre en place également  

IV. Chargement 
1.grâce à Shinyapp (ui=, server=) de l'UI et du Server , deux paramètres obligatoires afin que l'application se lance. 

==================

III. Partie 

Le logiciel stoppe toutefois  dans le cas d'une seule variable sélectionné. Si une seule variable est sélectionné, il est demandé d'entrer une valeur de référence qui va alors servir de seconde moyenne, hypothétique, à comparer. <br>
--
5.Variable identifiant : concernant certains tests, il peut être demandé d'indiquer une variable identifiant, notamment si les observations sont appariées . Cela permet alors de pouvoir utiliser ces données de groupes, et de pouvoir tester la significativité de la différence entre les deux groupes.

Choix automatique par H.normalité entre paramétriques et non-paramétriques
==================

Ainsi, il va tout d'abord tester les statistiques paramétriques, qui se basent donc sur la loi normale. Cela peut être un test de T de Student par exemple. De plus, l'histogramme de la variable explicative met en évidence la normalité de la distribution.  

D'un autre côté, on peut souligner la présence de statistiques semi-paramétriques .

Elles ne nécessitent pas l'hypothèse de normalité , qui est donc une hypothèse automatiquement vérifiée; et permettent également souvent à s'adapter à des situations particulières, comme comparer deux variables dichotomiques entre elles. 


Quand il y a deux variables ou plus, une variable Y peut être définie, ce qui permet de s'appuyer sur des packages qui font des régressions, également non -paramétriques. 
--

En ayant une sélection automatique du test (àl'exception de l'appariemment ou non )


Exemples d'utilisation de l'application{.storyboard}
==================
Dans cette section, on va effectuer quelques exemples d'application à l'aide du package mtcars chargé par défaut. 

Ainsi, on peut exécuter avec l'application ci-dessous un premier exemple à 1 variable : drat et qui exige donc à l'utilisateur d'indiquer en X , une valeur de référence.  

Ainsi, si l'on souhaite tester la différence significatve entre une variable, et la distribution hypothétique. Dans ce cadre , il faut donc  saisir en Y la variable et en X , la moyenne de la distribution hypothétique à comparer. Cette moyenne est calculée par l'utilisateur, qui peut par exemple utiliser la loi normale. 

Input : par exemple Y=drate et moyenne=3,9
Sortie : T=0 et absence significativité par le test de  Student et intervalle de confiances. 

2.Violation de l'hypothèse de normalité : Disp et cycl
But : l'application peut également calculer automatiquement les coefficients de corrélations spécifiques suivant la normalité ou non. 

Ici la sortie est le coefficient de Spearman,strictement positif,  et non de Pearson, étant donné que l'hypothèse de normalité , vérifiée par le test de Shapiro-Wilk , est violé.

Input : Disp et Cycl. 
Output : L'hypothèse de normalité est violée. 
Ainsi, le coefficient de Spearman est calculé car la significativité a été prouvée (à l'aide du test de la table de Spearman), voire l'utilisation du test de T de Student.

Cela souligne un lien croissant entre les deux variables, bien que l'ampleur n'est pas quantifiable. 

3. Vs(catégorielle) et référence value 
Ici, le logiciel va ainsi décider de calculer le test du Signe, qui est un test non paramétrique à 1 variable. 

La p value souligne une absence de significativité de la différence de médianes, entre valeur réelle et théorique, l'échantillon a donc bien une "médiane" raisonnable par rapport à la réalité. 

Ainsi, on remarque notamment en mettant une médiane de 20, que la médiane égale à 20 fait bien partie de l'intervalle de confiance. 

I.Charger l'ensemble des packages nécessaires. 

```{r,echo=FALSE}
#A lancé avec run : 
#Installer le package de template 
library("flexdashboard")

# Liste des packages à installer
packages <- c("rstatix", "DescTools", "shiny", "shinyjs", "DT", "rintrojs")

# Installer les packages qui ne sont pas encore installés
install.packages(setdiff(packages, rownames(installed.packages())))

#Packages nécessaires pour les tests statistiques

library(rstatix)
library(DescTools)
library(stats)
#Packages nécessaires afin de charger les données.
library(shiny)
library(shinyjs)
library(DT)
library(rintrojs)
```

#Partie I :Application



```{r,echo=FALSE, paged.print=FALSE, r}
app_ui <- function() {
  shiny::fluidPage( 
    
    #Crée une mise en page interactive pour l'utilisateur 
    rintrojs::introjsUI(),
    
    # titlepanel permet de créer le titre de l'application
    shiny::titlePanel(shiny::tags$h3("Statistiques : l'app de  stats", windowTitle = "Statistiques : l'app des tests stats")), 
    shiny::titlePanel(shiny::tags$h5(

    )
    ),
    # Je charge la librairie javscript de Shiny
    shinyjs::useShinyjs(),
    
    # Met en place la barre latérale qui permet de proposer de charger le Fichier
    shiny::sidebarLayout(
      shiny::sidebarPanel(
        # shiny::fileInput("file", "Upload a file"),
        
        shiny::actionButton("launch_modal", "Importation des données"),
        
        # Je mets en place le menu déroulant pour choisir la varaible expliquéeY
        rintrojs::introBox(
          shiny::uiOutput("expliquéeY_var_dropdown"),
          data.step = 3,
          data.intro = "Choose the expliquéeY variable from this dropdown."
        ),
        
        # Mettre le texte en-dessous 
        rintrojs::introBox(
          shiny::textOutput("expliquéeY_var_text"),
          data.step = 4,
          data.intro = "Cela est la variable expliquéeY"
        ),
        
        # Menu déroulant pour choisir la variable explicativeX
        rintrojs::introBox(
          shiny::uiOutput("explicativeX_var_dropdown"),
          data.step = 5,
          data.intro = "Choisit la variable explicativeX X "
        ),
        rintrojs::introBox(
          shiny::textOutput("explicativeX_var_text"), 
          data.step = 6,
          data.intro = "Cela permet de mettre en place la variable X  "
        ),
        
        # Champ de la saisie de la moyenne hypothètique qui est utile dans certain cas (ne s'actionne que si test du Wilcoxon)  
        rintrojs::introBox(
          shiny::uiOutput("input_mean"),
          data.step = 7,
          data.intro = "Entre la moyenne ici."
        ),
        shiny::conditionalPanel(
          condition = "input.statistical_test == 'Repeated measures ANOVA (paired)' || input.statistical_test == 'Multilevel Logistic Regression (paired)' || input.statistical_test == 'Friedman\\'s ANOVA II (paired)'",
          rintrojs::introBox(
            shiny::uiOutput("identifier_dropdown"),
            data.step = 8,
            data.intro = "Choisissez l'identifiant dans ce menu déroulant."
          )
        ),
        
        # Nouveau menu déroulant pour choisir le test statistique
        rintrojs::introBox(
          shiny::uiOutput("statistical_test_dropdown"),
          data.step = 9,
          data.intro = "Choisir le test statistique dans ce menu déroulant"
        ),
        
        # Endroit pour afficher le résultat du test 
        rintrojs::introBox(
          shiny::verbatimTextOutput("test_report"),
          data.step = 10,
          data.intro = "C'est l'endroit pour afficher les résultats du test. "
        )
      ),
      
      # Afficher les données importées de manière interactive (maxium 12 colonnes)
      shiny::mainPanel(
        shiny::fluidRow(
          shiny::column(width = 12, DT::dataTableOutput("dataTable")),
          shiny::column(width = 12, shiny::plotOutput("expliquéeY_var_histogramme"))
        ),#Permet d'afficher également  le graphique d'histogrammeme, qui est chargé dans la partie Server. 
      )
    )
  )
}

#Partie 1 : tentons de déterminer automatiquement,après sélections de variables, le test statistique 
#le test statistique le plus adapté (normalité). 

# Afficher un tableau de données
app_server <- function(input, output, session) {
display_data_table <- function(data) {
  DT::datatable(data)
}


# Etape 1 : déterminer le type de variable  et afficher une phrase sur l'interface (après mise à jour dans l'UI)
#le type de la variable expliquéeY afin d'appliquer le test statistique adapté. 

determine_expliquéeY_variable <- function(expliquéeY_var) {
  # Vérifions d'abord si la variable est numérique. 
  if (is.numeric(expliquéeY_var)) {
    # Vérifions si elle suit une loi Normale. 
    shapiro_test <- stats::shapiro.test(expliquéeY_var)

    # Or si pvalue<0,05 du test de Shapiro, cela  montre du coup qu'on a une normalité des résidus. 
    if (shapiro_test$p.value < 0.05) {
      "L'hypothèse de normalité est violée"
    } else {
      "L'hypothèse de normalité est vérifiée"
    }
  } else if (is.character(expliquéeY_var)) {
    # Classer si la variable Y est binaire, ou bien ordinal/nominal  
    unique_values <- length(unique(expliquéeY_var))
    if (unique_values == 2) {
      "La variable expliquéeY sélectionnée est binaire"
    } else if (unique_values > 2) {
      "La variable sélectionnée Y est multinomiale"
    } else {
      "La variable sélectionnée Y a des données invalides"
    }
  } else {
    "La variable sélectionnée n'est ni numérique ni caractère. "
  }
}

# 2 : Déterminer et afficher le type de la variable explicativeX Y

determine_explicativeX_variable <- function(explicativeX_var) {
  # Vérifie et affiche  si la variable explicativeX X sélectionnée est numérique ou pas . 
  if (is.numeric(explicativeX_var)) {
    "La variable explicativeX sélectionnée est numérique."
  } else if (is.numeric(explicativeX_var)) {
  # Calcule le nombre d'éléments distincts afin de mieux calsser la variable. 
    unique_values <- length(unique(explicativeX_var))
    if (unique_values == 2) {
      "La variable explicativeX sélectionnée est dichotomique."
    } else if (unique_values > 2) {
      "La variable explicativeX sélectionnée est catégorielle."
    } else {
      "La varaible dépendante a des données invalides"
    }
  } else {
    "La variable sélectionnée n'est ni numérique , ni une suite de caractères. "
  }
}

# Créer un graphique d'histogrammeme pour la variable dépendante
# Le paramètre est la variable indépendante.

créer_expliquéeY_variable_histogramme <- function(expliquéeY_var) {
  if (is.numeric(expliquéeY_var)) {
    graphics::hist(expliquéeY_var, main = "histogramme of expliquéeY Variable", xlab = "Values")
  }
}

#2. Mise en place de la fonction qui permet de classer les variables par types
#Elle va donc permettre de choisir le test statistique 

#Choisir un test statistique qui s'adapte correctement à notre varaible dépendante et explicativeX. 

SélectionTestStatistiques <- function(expliquéeY_var, explicativeX_var) {
  # Etape 1 : Déterminer les caractéristiques de la variable dépendante X 
  #Normalité Déterminer pour la variable numérique expliquéeY si elle suit une loi nominale ou non
  #Type : cela permet d'avoir une base pour la suite de nos tests 
  if (is.numeric(expliquéeY_var)) {
    shapiro_test <- stats::shapiro.test(expliquéeY_var)
    if (shapiro_test$p.value < 0.05) {
      expliquéeY_var_caractéristique <- "L'hypothèse de normalité est violée"
    } else {
      expliquéeY_var_caractéristique <- "L'hypothèse de normalité est vérifiée"
    }
  } else if (is.character(expliquéeY_var)) {
    unique_values <- length(unique(expliquéeY_var))
    if (unique_values == 2) {
      expliquéeY_var_caractéristique <- "binaire"
    } else if (unique_values > 2) {
      expliquéeY_var_caractéristique <- "multinomialouordinal"
    }
  } else {
    return("La variable expliquéeY n'est pas supportée")
  }
  #Si multinomial : cela signifie notamment que l'on va devoir utiliser un test semi-paramétrique (ANOVA)
  if (is.numeric(explicativeX_var)) {
    explicativeX_var_caractéristique <- "continue"
  } else if (is.character(explicativeX_var)) {
    unique_explicativeX <- length(unique(explicativeX_var)) #Déterminer le nombre de valeur uniques. 
    if (unique_explicativeX == 1) {
      explicativeX_var_caractéristique <- "unique"
    } else if (unique_explicativeX == 2) {
      explicativeX_var_caractéristique <- "catégorielle"
    } else if (unique_explicativeX > 2) {
      explicativeX_var_caractéristique <- "catégorielle"#Permet de mettre en place potentiellement un test semi-paramétrique. 
    } else {
      #Si la variable est catégorique 
      return("La varialbe indépendante n'est pas supportée")
    }
  }


  # Utiliser ces caractéristiques pour choisir le test statistique. 
  #On place dans les deux premières boucles : la condition de normalité de Y et son types 
  #Au contraire, on place dans les secondes boucles les types de X contenu dans la variable 
  #Tout a été chargé dans les var
  if (expliquéeY_var_caractéristique == "L'hypothèse de normalité est violée") {
    if (explicativeX_var_caractéristique == "continue") {
      return("Coeff de corrélation de Spearman")
    } else if (explicativeX_var_caractéristique == "unique") {
      return("Test du signe")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c(
        "Wilcoxon test",
        "Mann-Whitney U test 2 (non apparié)"
      ))
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c(
        # "Test d'ANOVA apparié",
        "Kruskal-Wallis test 1 (explicativeX)"
      ))
    }
  } else if (expliquéeY_var_caractéristique == "L'hypothèse de normalité est vérifiée") {
    if (explicativeX_var_caractéristique == "continue") {
      return("Coeff de corrélation de Pearson")
    } else if (explicativeX_var_caractéristique == "unique") {
      return("Tstudent 1 echantillon")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c("explicativeX samples t-test (non apparié)", "T-test (test apparié)"))
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c("One-way ANOVA (unpaired)"
               # "analyse de la variance à mesures répétées (appariée)"
      ))
    } #Mettons en place les tests également pour les régresions logistiques. 
  } else if (expliquéeY_var_caractéristique == "binaire") {
    if (explicativeX_var_caractéristique == "unique") {
      return("Test du khi carre d'adequation")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c("Test de McNemar (apparié)", "Chi carré test d'indépendance  avec le test de Fisher (non apparié)"))
    #Test de McNemar : permet de vérifier si les proportions entre les deux "catégories" sont significativement différentes ou non. 
    } else if (explicativeX_var_caractéristique == "catégorielle & unpaired") {
      return("Test du Chi Carré d'indépendance  et test de Fischer non apparié")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c(
        "Cochran's Q test "
        # "Cochran's Q test (paired)"
      ))
    }
    #Le test de Cohran permet de comparer deux variables dichotomiques entre elles.
  } else if (expliquéeY_var_caractéristique == "catégorielleouordinal") {
    if (explicativeX_var_caractéristique == "unique") {
      return("Chi2 R2 test et test multinomial")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c(
        "Chi-Square Test of indépendence and Fisher-Freeman-Halton Exact Test I (unpaired)",
        "Mann-Whitney U test 2 (non apparié)",
        "Bhapkar's Test",
        "Wilcoxon test"
      ))
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c(
        # "régression logistique multiniveau (appariée)",
        # "Friedman's ANOVA II (paired)",
        "Chi-Square Test of indépendance en Fisher-Freeman-Halton Exact Test I (unpaired)",
        "Kruskal-Wallis test 1 (explicativeX)"
      ))
    }
  }

  # Pas de test statistique approuvé trouvé. 
  return("Pas de test statistique utile trouvé en lien avec la combinaison de variables X et explicative Y")
}

#Etape 4 : mette en place une fonction pour calculer la normalité 
#Analyser uniquement la normalité d'une variable et adapter le message suivant le résultat. 

get_variable_class_info <- function(variable) {
  if (is.numeric(variable)) {
    # Faire un test shapiro wilk pour effectuer la normalité
    sw_test <- stats::shapiro.test(variable)
    is_normal <- sw_test$p.value >= 0.05

    # Créer un vecteur de character pour sauvegarder le résultat. 
    var_class_info <- character(0)

    if (is_normal) {
      var_class_info <- c(var_class_info, "independante Variable Class: continue (Normally Distributed)")
    } else {
      var_class_info <- c(var_class_info, "independante Variable Class: continue (Not Normally Distributed)")
      # Inclure le test de Shapiro avec une p-value
      shapiro_result <- paste("Shapiro-Wilk Test: p-value =", format(sw_test$p.value, digits = 4))
      var_class_info <- c(var_class_info, shapiro_result)
    }

    return(var_class_info)
  } else {
    # Vérifie si la variable catégorique est binaire ou pas. 
    unique_values <- unique(variable)
    is_binaire <- length(unique_values) == 2

    if (is_binaire) {
      var_class_info <- "explicativeX Variable Class: Categorical (binaire)"
    } else {
      var_class_info <- "explicativeX Variable Class: Categorical (Nominal)"
    }

    return(var_class_info)
  }
}



# Etape 5 : exécuter le test à partir des packages.  Cette fonction va effectuer les tests statistiques à partir de la base de données donné par l'utilisateur. 

#Variables qui ont les différentes données pour les variables. 
perform_statistical_test <- function(data, input) {
  test_name <- input$statistical_test
  expliquéeY_var <- input$expliquéeY_var
  explicativeX_var <- input$explicativeX_var
  identifier_var <- input$identifier_var
  input_mean <- input$input_mean

  # Determiner la valuer de mu basé sur les sélections de l'utilisateur
  #IL est important d'insérer une moyenne hypothétique pour certains tests , notamment ceux ne se basant que sur Y (notamment si "reference value" est mise en place. 
  mu <- if (explicativeX_var == "reference value") input_mean else mean(data[[expliquéeY_var]], na.rm = TRUE)

  # Exécuté les tests 
  #On utilise trycatch qui permet notamment de mettre en place une autre fonction en cas d'erreur
  
  result <- tryCatch(
    {
      switch(test_name,
             "Test du signe" = DescTools::SignTest(x = data[[expliquéeY_var]], mu = mu, alternative = "two.sided"),
             "Wilcoxon test" = stats::wilcox.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]], data, paired = TRUE, alternative = "two.sided"),
             "Mann-Whitney U test 2 (non apparié)" = {
               unique_values <- unique(data[[explicativeX_var]])
               groupee1 <- data[data[[explicativeX_var]] == unique_values[1], expliquéeY_var]
               groupee2 <- data[data[[explicativeX_var]] == unique_values[2], expliquéeY_var]
               stats::wilcox.test(groupee1, groupee2, paired = FALSE, alternative = "two.sided", conf.int = TRUE)
             },
             "Kruskal-Wallis test 1 (explicativeX)" = stats::kruskal.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]], data),
             "Tstudent 1 echantillon" = stats::t.test(data[[expliquéeY_var]], mu = mu, alternative = "two.sided"),
             "T-test (test apparié)" = stats::t.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]], data, paired = TRUE, alternative = "two.sided", var.equal = FALSE),
             "explicativeX samples t-test (non apparié)" = {
               data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
               if (length(levels(data[[explicativeX_var]])) != 2) stop("The explicativeX variable must have exactly two levels for an explicativeX t-test.")
               part_one <- stats::t.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]], data, paired = FALSE, alternative = "two.sided", var.equal = FALSE)

               formula <- stats::as.formula(paste(substitute(expliquéeY_var), "~", substitute(explicativeX_var))) ## formula working example!
               part_two <- rstatix::cohens_d(data, formula,
                                             var.equal = TRUE)

               c(part_one, part_two)

             },
             # "analyse de la variance à mesures répétées (appariée)" = perform_repeated_measures_anova(data, expliquéeY_var, identifier_var, explicativeX_var),
             "One-way ANOVA (unpaired)" = {
               data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
               res.aov <- stats::aov(data[[expliquéeY_var]] ~ data[[explicativeX_var]])
               summary(res.aov)
             },
             "CTest du khi carré d'adéquation" = {
               table_var <- table(data[[expliquéeY_var]], useNA = "no")
               reference_value <- if (explicativeX_var == "reference value") input_mean else max(table_var) / sum(table_var)
               stats::chisq.test(table_var, p = c(1 - reference_value, reference_value))
             },
             " test de McNemar (appareillé)" = { ## Error: Error in exact2x2::exact2x2(groupee_matrix, paired = TRUE, midp = TRUE): 'x' must have at least 2 rows and columns
               unique_values <- unique(data[[explicativeX_var]])
               groupee1 <- data[data[[explicativeX_var]] == unique_values[1], expliquéeY_var]
               groupee2 <- data[data[[explicativeX_var]] == unique_values[2], expliquéeY_var]
               groupee_matrix <- table(groupe1, groupe2)
               exact2x2::exact2x2(groupe_matrix, paired = TRUE, midp = TRUE)
             },#Test sur donnée nominale dichtomoique
             "Test du Chi-carré d'indépendance et test exact de Fisher (non apparié)" = stats::chisq.test(data[[expliquéeY_var]], data[[explicativeX_var]]),
             "Bhapkar's Test" = {
               unique_values <- unique(data[[explicativeX_var]])
               groupee1 <- data[data[[explicativeX_var]] == unique_values[1], expliquéeY_var]
               groupee2 <- data[data[[explicativeX_var]] == unique_values[2], expliquéeY_var]
               irr::bhapkar(cbind(groupe1, groupe2))
             },
             "Test des rangs signés de Wilcoxon II (appareillé" = {
               data[[expliquéeY_var]] <- as.numeric(as.factor(data[[expliquéeY_var]]))
               stats::wilcox.test(data[[expliquéeY_var]], paired = TRUE)
             },
             "Coeff de corrélation de Pearson" = stats::cor(data[[expliquéeY_var]], data[[explicativeX_var]], method = "pearson"),
             "Coeff de corrélation de Spearman" = stats::cor(data[[expliquéeY_var]], data[[explicativeX_var]], method = "spearman"),
             "Cochran's Q Test (paired)" = {
             data[[expliquéeY_var]] <- as.factor(data[[expliquéeY_var]])
             data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
             rstatix::cochran_qtest(data[[expliquéeY_var]] ~ data[[explicativeX_var]] | data[[identifier_var]], data)
             },
             "Test exact de Fischer" = {
               data[[expliquéeY_var]] <- as.factor(data[[expliquéeY_var]])
               data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
               stats::fisher.test(data[[expliquéeY_var]], data[[explicativeX_var]])
             },
             #Partie de tests non paramétrique  : 
             "Test d'ANOVA apparié" = {
              data[[expliquéeY_var]] <- as.numeric(data[[expliquéeY_var]])
             data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
             message(identifier_var)
             formula <- stats::as.formula(paste(substitute(expliquéeY_var), "~", substitute(explicativeX_var), "|", substitute(identifier_var)))
             stats::friedman.test(substitute(expliquéeY_var) ~ substitute(explicativeX_var) | substitute(identifier_var), data)
             stats::friedman.test(formula, data)
             },
             "Friedman's ANOVA II (paired)" = {
             
             
                message(expliquéeY_var)
             
                message(deparse(expliquéeY_var))
                message(substitute(expliquéeY_var))
                message(deparse(substitute(expliquéeY_var)))
             
                perform_friedman_test_now(data, substitute(expliquéeY_var), substitute(explicativeX_var), substitute(identifier_var))
                   data[[expliquéeY_var]] <- as.numeric(data[[expliquéeY_var]])
                   data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
                 stats::friedman.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]] | data[[identifier_var]], data)
               },
                "régression logistique multiniveau (appariée)" = {
                 data[[expliquéeY_var]] <- as.factor(data[[expliquéeY_var]])
                 data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
                 message(identifier_var)
                 lme4::glmer(data[[expliquéeY_var]] ~ data[[explicativeX_var]] + (1 | data[[identifier_var]]), data, family = binomial)
              },
             stop(paste0("No appropriate statistical test found for the given combination of expliquéeY and explicativeX variables: ", expliquéeY_var, " and ", explicativeX_var))
      )
    }, #S'il y a erreur , on va alors afficher le code suivant , qui va donc permettre de spécifier le type d'erreur : 
    error = function(e) {
      stop(paste0("Error: ", e))#e : permet de capter le message d'erreur 
      NULL
    }
  )

  return(result)
}

#Créer le serveur 


  shiny::observeEvent(input$launch_modal, {
    datamods::import_modal(
      id = "myid",
      from = c("env", "file", "copypaste", "googlesheets", "url"),
      title = "Import data to be used in application"
    )
  })
  
  imported <- datamods::import_server("myid", return_class = "data.frame")
  
  sdata <- shiny::reactive({ #Reactive permet de mettre à jour les données ,notamment la base de données. 
    if (is.null(imported$data())) {#S'il n'y a pas de data set chargé, il charge "mtcars" qui est une base de donnée de R classique. 
      datasets::mtcars
    } else {
      shiny::req(imported$data()) #Si importé=pas 0, on utilise Req permet de vérifier l'absence de données manquantes en plus
      if (nrow(imported$data()) == 0) {  #si après avoir enlever les NA, la base de donnée =0
        datasets::mtcars
      } else {
        imported$data() 
      }
    }
  })
  
  
  
  # Afficher la base de données sous le format de la Datatable. 
  output$dataTable <- DT::renderDataTable({
    shiny::req(sdata())
    DT::datatable(sdata())
  })
  
  # Créer le menu  déroulant pour la variable expliquéeY variable
  output$expliquéeY_var_dropdown <- shiny::renderUI({
    shiny::req(sdata())
    shinyWidgets::pickerInput("expliquéeY_var", "Choisir la variable expliquéeY X", choices = colnames(sdata()))
  })
  
  # Menu déroulant pour la variable explicative X . 
  output$explicativeX_var_dropdown <- shiny::renderUI({
    shiny::req(sdata())
    choices <- c("reference value", colnames(sdata()))
    shinyWidgets::pickerInput(
      "explicativeX_var",
      "Choisir la variable explicativeX ou de référence",
      choices = choices
    )
  })
  
  output$input_mean <- shiny::renderUI({
    shiny::req(sdata())
    shiny::req(input$expliquéeY_var)
    
    ## Récupérer les données des entrées utilisateur.
    data <- sdata()
    
    ## Calculer la moyenne des données 
    if (is.numeric(data[[input$expliquéeY_var]])) {
      reference_value <- mean(data[[input$expliquéeY_var]], na.rm = TRUE)
    } else {
      reference_value <- NULL
    }
    
    ## Seule montrer l'input mean si la valeur de référence est actionnée. 
    #Cela permet d'écrire la valeur de référence qui va permettre notamment de comparer dans certain tests notamment à 1 valeur comme le test du Signe. 
    if (input$explicativeX_var == "reference value") {
      shiny::numericInput("input_mean", "Set reference value", value = reference_value)
    }
  })
  
  # Menu déroulant dynamique qui permet notamment de sélectionner une variable identifiante ID, en fonction des variables explicatives. 
  #cela est surtout utile pour les groupes appareillés ou non (ANOVA)
  #Et cela permet donc de sélectionner les identifants en "doublons".  
  output$identifier_dropdown <- shiny::renderUI({
    shiny::req(sdata())
    shinyWidgets::pickerInput("identifier_var", "Choisir la variable identifiée", choices = colnames(sdata()))
  })
  
  # Menu déroulant des variables expliquéeYs
  output$expliquéeY_var_text <- shiny::renderText({
    shiny::req(input$expliquéeY_var)
    determine_expliquéeY_variable(sdata()[, input$expliquéeY_var])
  })
  
  # Texte additionnel pour la variable explicativeX. 
  output$explicativeX_var_text <- shiny::renderText({
    shiny::req(input$explicativeX_var)
    
    if (input$explicativeX_var %in% colnames(sdata())) {
      determine_explicativeX_variable(sdata()[, input$explicativeX_var])
    }
  })
  
  # Nouveau menu déroulant pour sélectionner le test statistique. 
  output$statistical_test_dropdown <- shiny::renderUI({
    shiny::req(input$expliquéeY_var, input$explicativeX_var)
    
    if (input$explicativeX_var == "reference value") {
      explicativeX_var <- "valeur de référence"
    } else {
      explicativeX_var <- sdata()[, input$explicativeX_var]
    }
    test <- SélectionTestStatistiques(sdata()[, input$expliquéeY_var], explicativeX_var)
    test_options <- c(test)
    shinyWidgets::pickerInput("statistical_test", "Choose statistical test", choices = test_options)
  })
  
  # Afficher l'histogramme de la variable Y sélectionnée.
output$expliquéeY_var_histogramme <- shiny::renderPlot({
    shiny::req(sdata(), input$expliquéeY_var)
    créer_expliquéeY_variable_histogramme(sdata()[, input$expliquéeY_var])
})

  # 4.Exporter les tests statistiques
output$test_report <- shiny::renderPrint({
  result <- perform_statistical_test(sdata(), input)
  if (!is.null(result)) result
})
}

shinyApp(ui=app_ui,server=app_server)
```

Partie 2 : logiciel de comparaison de performances de modèles avec variables différentes sélectionnées
==========================================

```{r}

```


Partie 3 : Explication du code Shiny sans exécution
============================
Comme Shiny oblige à avoir le server et l'UI dans le même Chunk, on va donc devoir détailler ici présent le code afin de le rendre le plus explicite possible. 

##Présentation de Shiny 
Shiny est un framework web pour le développement d'applications Web. Il est gratuit et open source et est développé par RStudio. 

Quel est le but de R shiny ? 
Shiny a été créé afin de proposer une solution interactive aux utilisateurs de R. 

Qu'est-ce que signifie exactement ce côté "interactif" et non statique ? 
Tout simplement, Shiny permet de modifier les bases de données en temps réel, permettant d'utiliser et réutiliser d'autres bases de données. 

Comment peux-t-on facilement comprendre la structure de R Shiny ? 
R Shiny est composé de deux parties principales, qui peuvent être stockées dans deux fichiers distincts. Cela n'est donc pas le cas dans mon document !

La 1ere partie est l'interface UI , ou l'interface utilisateur, qui permet de stocker les choix par défaut de l'utilisateur. En effet , l'utilisateur sélectionne des variables via son menu déroulant. 

La deuxième partie de l'application Shiny, est le back-end, càdire qu'il s'agit d'une partie qui est conçue pour accueillir tout les calculs de tests statistiques, la génération de graphiques. Cette partie peut peut être écrite entièrement dans le code R.

Première étape :construire l'interface interactive (UI)
============================

#1. Partie UI 
En effet, notamment, la partie UI permet de mettre en place l'interface graphique, et par là d'obtenir les choix de l'utilisateur. 



#I.Créer la mise en page UI

La fonction shiny::fluidPage() crée une mise en page fluide pour une application Shiny, permettant aux éléments de s'ajuster dynamiquement à la taille de la fenêtre du navigateur. 

Ainsi, elle sert de conteneur principal pour organiser divers composants de l'interface utilisateur tels que les titres, les barres latérales, les panneaux principaux, les graphiques et les tableaux. 

De plus, elle facilite également l'utilisation de grilles et de conteneurs pour structurer l'agencement des éléments de manière intuitive. En résumé, fluidPage() est essentielle pour concevoir des interfaces utilisateur flexibles et adaptatives dans les applications Shiny.

```{r eval=FALSE}
app_ui <- function() {
  shiny::fluidPage( 
    rintrojs::introjsUI(),
    
    
```

#2.La mise en place du titre et de l'interface graphique de la console de paramètres. 

Le titre est d'emblée mis en place grâce à Titlepanel. 

Par ailleurs, il me semble important de souligner que j'ai utilisé également la version Javascript de Rshiny, shinyjs. 

sidebarLayout crée une mise en page avec une barre latérale et une zone principale dans votre application Shiny.

Afin de recueillir les entrées des utilisateurs, par le biais de bouton ou de menu déroulant, j'utilise la fonction shiny qui s'appelle sidebarPanel, et qui est essentielle étant donnée qu'elle permet de mettre en place les choix .Elle permet de saisir les paramètres de nos tests statistiques. 

Par exemple , dans ce sidebarpanel, on va pouvoir mettre en place le bouton d'importation qui permet de charger la base de donnée.  
Ainsi, par exemple dans ce menu déroulant, on va pouvoir ajouter une Introbox, qui va permettre d'intégrer les étapes de tutoriel interactif. (à voir si je réussis à l'ajouter)

Par ailleurs, chacun de ces boutons a comme argument la variable qui permettra par la suite au "server" de faire les calculs. 

```{r eval=FALSE}
# titlepanel permet de créer le titre de l'application
    shiny::titlePanel(shiny::tags$h3("Statistiques : l'app de  stats", windowTitle = "Statistiques : l'app des tests stats")), 
    shiny::titlePanel(shiny::tags$h5(

    )
    ),
    # Je charge la librairie javscript de Shiny
    shinyjs::useShinyjs(),
    
    # Met en place la barre latérale qui permet de proposer de charger le Fichier
    shiny::sidebarLayout(
      shiny::sidebarPanel(
        # shiny::fileInput("file", "Upload a file"),
        
        shiny::actionButton("launch_modal", "Importation des données"),
        
        # Je mets en place le menu déroulant pour choisir la varaible expliquéeY
        rintrojs::introBox(
          shiny::uiOutput("expliquéeY_var_dropdown"),
          data.step = 3,
          data.intro = "Choose the expliquéeY variable from this dropdown."
        ),
        
        # Mettre le texte en-dessous 
        rintrojs::introBox(
          shiny::textOutput("expliquéeY_var_text"),
          data.step = 4,
          data.intro = "Cela est la variable expliquéeY"
        ),
        
        # Menu déroulant pour choisir la variable explicativeX
        rintrojs::introBox(
          shiny::uiOutput("explicativeX_var_dropdown"),
          data.step = 5,
          data.intro = "Choisit la variable explicativeX X "
        ),
    rintrojs::introjsUI(),

```


3. Créer la console principale 


Cette fonction mainpanel définit la zone principale de l'interface utilisateur de l'application Shiny, où les résultats et les visualisations seront affichés.

fluidRow organise le contenu en une ligne fluide et réactive, permettant aux éléments internes de s'ajuster automatiquement à la taille de la fenêtre du navigateur

```{r eval=FALSE}
Afficher les données importées de manière interactive (maxium 12 colonnes)
      shiny::mainPanel(
        shiny::fluidRow(
          shiny::column(width = 12, DT::dataTableOutput("dataTable")),
          shiny::column(width = 12, shiny::plotOutput("expliquéeY_var_histogramme"))
        ),#Permet d'afficher également  le graphique d'histogrammeme, qui est chargé dans la partie Server. 
      )
    )
  )
}



# Créer un graphique d'histogrammeme pour la variable dépendante
```
Partie serveur : fonctions et calculs des tests
=========================
#II.Server

La fonction appServer est constituée essentiellement de code R, excepté certaine fonction pour les graphiques, souvent commençant par render.Ainsi, elle correspond à la partie serveur de shiny. 
Elle permet comme indiqué en introduction de se concentrer sur les calculs complexes ; et donc d'"implémenter" les fonctions de la variable UI. 


1. Boucle if-else et création d'un programme et de messages

Cette fonction prend un jeu de données en entrée et le transforme en un tableau interactif grâce à DT::datatable, facilitant ainsi la visualisation des données dans l'application.
determine_expliquéeY_variable :

Elle évalue la variable expliquéeY pour déterminer son type (numérique ou catégorique). Si numérique, elle effectue un test de normalité de Shapiro-Wilk et indique si l'hypothèse de normalité est vérifiée ou violée. Pour les variables catégoriques/caractères , elle identifie si elles sont binaires ou multinomiales. On peut souligner notamment que le type "caractère" doit être présent pour que les boucles fonctionnent. 

Cette fonction utilise également  la variable explicativeX en vérifiant si elle est numérique. Si non numérique, elle détermine si elle est dichotomique ou catégorielle en fonction du nombre de valeurs uniques, fournissant ainsi des informations sur le type de variable sélectionnée.

Ainsi, cette fonction permet d'afficher des messages liées aux types. Toutefois, une deuxième fonction est mise en place par la suite afin de charger dans un vecteur de caractéristique le type de variable. 

Cette caractérisation est la base, in fine, de la bonne adéquation de nos tests statistiques aux variables concernées. Certains détails ont été mis en commentaires. 
Ainsi , toute nos variables peuvent suivre une loi normale, soit pas. 
Ensuite, nos variables peuvent être de type quantitatif, binaire, voire catégorielle. Ainsi, cela va particulièrement influencé le choix du test statistique. 

On peut remarquer ainsi l'efficacité du test du signe , par exemple, qui est effectuée pour des variables dichotomiques. 
On peut également remarquer qu'un test est régulièrement effectuée, non paramétrique, est celui de la corrélation de Spearman, qui indique uniquement le sens de la variation. 


```{r eval=FALSE }
#Partie 1 : tentons de déterminer automatiquement,après sélections de variables, le type.  

# Afficher un tableau de données
app_server <- function(input, output, session) {
display_data_table <- function(data) {
  DT::datatable(data)
}


# Etape 1 : déterminer le type de variable  et afficher une phrase sur l'interface (après mise à jour dans l'UI)
#le type de la variable expliquéeY afin d'appliquer le test statistique adapté. 

determine_expliquéeY_variable <- function(expliquéeY_var) {
  # Vérifions d'abord si la variable est numérique. 
  if (is.numeric(expliquéeY_var)) {
    # Vérifions si elle suit une loi Normale. 
    shapiro_test <- stats::shapiro.test(expliquéeY_var)

    # Or si pvalue<0,05 du test de Shapiro, cela  montre du coup qu'on a une normalité des résidus. 
    if (shapiro_test$p.value < 0.05) {
      "L'hypothèse de normalité est violée"
    } else {
      "L'hypothèse de normalité est vérifiée"
    }
  } else if (is.character(expliquéeY_var)) {
    # Classer si la variable Y est binaire, ou bien ordinal/nominal  
    unique_values <- length(unique(expliquéeY_var))
    if (unique_values == 2) {
      "La variable expliquéeY sélectionnée est binaire"
    } else if (unique_values > 2) {
      "La variable sélectionnée Y est multinomiale"
    } else {
      "La variable sélectionnée Y a des données invalides"
    }
  } else {
    "La variable sélectionnée n'est ni numérique ni caractère. "
  }
}

# 2 : Déterminer et afficher le type de la variable explicativeX Y

determine_explicativeX_variable <- function(explicativeX_var) {
  # Vérifie et affiche  si la variable explicativeX X sélectionnée est numérique ou pas . 
  if (is.numeric(explicativeX_var)) {
    "La variable explicativeX sélectionnée est numérique."
  } else if (is.numeric(explicativeX_var)) {
  # Calcule le nombre d'éléments distincts afin de mieux calsser la variable. 
    unique_values <- length(unique(explicativeX_var))
    if (unique_values == 2) {
      "La variable explicativeX sélectionnée est dichotomique."
    } else if (unique_values > 2) {
      "La variable explicativeX sélectionnée est catégorielle."
    } else {
      "La varaible dépendante a des données invalides"
    }
  } else {
    "La variable sélectionnée n'est ni numérique , ni une suite de caractères. "
  }
}
```

2.Associer le type de variables et le bon test statistique

Ainsi, on peut créer une fonction de statistique.Celle-ci va notamment associer le test adéquat aux types de variables rencontrés, suivant le type de la variable. 

Cela est effectuée grâce à des if-else, et également à return. 


```{r eval=FALSE}
if (expliquéeY_var_caractéristique == "L'hypothèse de normalité est violée") {
    if (explicativeX_var_caractéristique == "continue") {
      return("Coeff de corrélation de Spearman")
    } else if (explicativeX_var_caractéristique == "unique") {
      return("Test du signe")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c(
        "Wilcoxon test",
        "Mann-Whitney U test 2 (non apparié)"
      ))
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c(
        # "Test d'ANOVA apparié",
        "Kruskal-Wallis test 1 (explicativeX)"
      ))
    }
  } else if (expliquéeY_var_caractéristique == "L'hypothèse de normalité est vérifiée") {
    if (explicativeX_var_caractéristique == "continue") {
      return("Coeff de corrélation de Pearson")
    } else if (explicativeX_var_caractéristique == "unique") {
      return("Tstudent 1 echantillon")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c("explicativeX samples t-test (non apparié)", "T-test (test apparié)"))
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c("One-way ANOVA (unpaired)"
               # "analyse de la variance à mesures répétées (appariée)"
      ))
    } #Mettons en place les tests également pour les régresions logistiques. 
  } else if (expliquéeY_var_caractéristique == "binaire") {
    if (explicativeX_var_caractéristique == "unique") {
      return("Test du khi carre d'adequation")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c("Test de McNemar (apparié)", "Chi carré test d'indépendance  avec le test de Fisher (non apparié)"))
    #Test de McNemar : permet de vérifier si les proportions entre les deux "catégories" sont significativement différentes ou non. 
    } else if (explicativeX_var_caractéristique == "catégorielle & unpaired") {
      return("Test du Chi Carré d'indépendance  et test de Fischer non apparié")
    } else if (explicativeX_var_caractéristique == "catégorielle") {
      return(c(
        "Cochran's Q test "
        # "Cochran's Q test (paired)"
      ))
    }
```
##3. Calculer les tests statistiques. 
Afin de pouvoir calculer les test statistiques, il ne faut surtout pas oublier de charger tout les packages disponibles. 

L'association du test et son exécution est symbolisée par switch(). 
La fonction switch(test_name, ...) choisit et exécute un test statistique spécifique basé sur la valeur de la variable test_name que l'on a mis en place auparavant.



```{r eval=FALSE}
#Calculons les tests statistiques avec une fonction de débug. 


  result <- tryCatch(
    {
      switch(test_name,
             "Test du signe" = DescTools::SignTest(x = data[[expliquéeY_var]], mu = mu, alternative = "two.sided"),
             "Wilcoxon test" = stats::wilcox.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]], data, paired = TRUE, alternative = "two.sided"),
             "Mann-Whitney U test 2 (non apparié)" = {
               unique_values <- unique(data[[explicativeX_var]])
               groupee1 <- data[data[[explicativeX_var]] == unique_values[1], expliquéeY_var]
               groupee2 <- data[data[[explicativeX_var]] == unique_values[2], expliquéeY_var]
               stats::wilcox.test(groupee1, groupee2, paired = FALSE, alternative = "two.sided", conf.int = TRUE)
             },
             "Kruskal-Wallis test 1 (explicativeX)" = stats::kruskal.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]], data),
             "Tstudent 1 echantillon" = stats::t.test(data[[expliquéeY_var]], mu = mu, alternative = "two.sided"),
             "T-test (test apparié)" = stats::t.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]], data, paired = TRUE, alternative = "two.sided", var.equal = FALSE),
             "explicativeX samples t-test (non apparié)" = {
               data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
               if (length(levels(data[[explicativeX_var]])) != 2) stop("The explicativeX variable must have exactly two levels for an explicativeX t-test.")
               part_one <- stats::t.test(data[[expliquéeY_var]] ~ data[[explicativeX_var]], data, paired = FALSE, alternative = "two.sided", var.equal = FALSE)

               formula <- stats::as.formula(paste(substitute(expliquéeY_var), "~", substitute(explicativeX_var))) ## formula working example!
               part_two <- rstatix::cohens_d(data, formula,
                                             var.equal = TRUE)

               c(part_one, part_two)

             },
             # "analyse de la variance à mesures répétées (appariée)" = perform_repeated_measures_anova(data, expliquéeY_var, identifier_var, explicativeX_var),
             "One-way ANOVA (unpaired)" = {
               data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
               res.aov <- stats::aov(data[[expliquéeY_var]] ~ data[[explicativeX_var]])
               summary(res.aov)
             },
             "CTest du khi carré d'adéquation" = {
               table_var <- table(data[[expliquéeY_var]], useNA = "no")
               reference_value <- if (explicativeX_var == "reference value") input_mean else max(table_var) / sum(table_var)
               stats::chisq.test(table_var, p = c(1 - reference_value, reference_value))
             },
             " test de McNemar (appareillé)" = { ## Error: Error in exact2x2::exact2x2(groupee_matrix, paired = TRUE, midp = TRUE): 'x' must have at least 2 rows and columns
               unique_values <- unique(data[[explicativeX_var]])
               groupee1 <- data[data[[explicativeX_var]] == unique_values[1], expliquéeY_var]
               groupee2 <- data[data[[explicativeX_var]] == unique_values[2], expliquéeY_var]
               groupee_matrix <- table(groupe1, groupe2)
               exact2x2::exact2x2(groupe_matrix, paired = TRUE, midp = TRUE)
             },#Test sur donnée nominale dichtomoique
             "Test du Chi-carré d'indépendance et test exact de Fisher (non apparié)" = stats::chisq.test(data[[expliquéeY_var]], data[[explicativeX_var]]),
             "Bhapkar's Test" = {
               unique_values <- unique(data[[explicativeX_var]])
               groupee1 <- data[data[[explicativeX_var]] == unique_values[1], expliquéeY_var]
               groupee2 <- data[data[[explicativeX_var]] == unique_values[2], expliquéeY_var]
               irr::bhapkar(cbind(groupe1, groupe2))
             },
             "Test des rangs signés de Wilcoxon II (appareillé" = {
               data[[expliquéeY_var]] <- as.numeric(as.factor(data[[expliquéeY_var]]))
               stats::wilcox.test(data[[expliquéeY_var]], paired = TRUE)
             },
             "Coeff de corrélation de Pearson" = stats::cor(data[[expliquéeY_var]], data[[explicativeX_var]], method = "pearson"),
             "Coeff de corrélation de Spearman" = stats::cor(data[[expliquéeY_var]], data[[explicativeX_var]], method = "spearman"),
             "Cochran's Q Test (paired)" = {
             data[[expliquéeY_var]] <- as.factor(data[[expliquéeY_var]])
             data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
             rstatix::cochran_qtest(data[[expliquéeY_var]] ~ data[[explicativeX_var]] | data[[identifier_var]], data)
             },
             "Test exact de Fischer" = {
               data[[expliquéeY_var]] <- as.factor(data[[expliquéeY_var]])
               data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
               stats::fisher.test(data[[expliquéeY_var]], data[[explicativeX_var]])
             },
             #Partie de tests non paramétrique  : 
             "Test d'ANOVA apparié" = {
              data[[expliquéeY_var]] <- as.numeric(data[[expliquéeY_var]])
             data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
             message(identifier_var)
             formula <- stats::as.formula(paste(substitute(expliquéeY_var), "~", substitute(explicativeX_var), "|", substitute(identifier_var)))
             stats::friedman.test(substitute(expliquéeY_var) ~ substitute(explicativeX_var) | substitute(identifier_var), data)
             stats::friedman.test(formula, data)
             },
             "Friedman's ANOVA II (paired)" = {
             
             
                message(expliquéeY_var)
             
                message(deparse(expliquéeY_var))
                message(substitute(expliquéeY_var))
                message(deparse(substitute(expliquéeY_var)))
             
                perform_friedman_test_now(data, substitute(expliquéeY_var), substitute(explicativeX_var), substitute(identifier_var))
                   data[[expliquéeY_var]] <- as.numeric(data[[expliquéeY_var]])
                   data[[explicativeX_var]] <- as.factor(data[[explicativeX_var]])
```
```{r}

```
#4.Implémenter les éléments de l'interface graphique. 

Toutefois, il faut notamment souligner qu'il est nécessaire d'implémenter dans Server certains éléments de l'interface graphique. 
Par exemple, rendre réactif le menu déroulant des varaibles se déroule dans la partie server. 
Evidemment, il est important d'exporter les résultats. 


```{r eval=FALSE}

  output$identifier_dropdown <- shiny::renderUI({
    shiny::req(sdata())
    shinyWidgets::pickerInput("identifier_var", "Choisir la variable identifiée", choices = colnames(sdata()))
  })
  
  # Menu déroulant des variables expliquéeYs
  output$expliquéeY_var_text <- shiny::renderText({
    shiny::req(input$expliquéeY_var)
    determine_expliquéeY_variable(sdata()[, input$expliquéeY_var])
  })
  
  # Texte additionnel pour la variable explicativeX. 
  output$explicativeX_var_text <- shiny::renderText({
    shiny::req(input$explicativeX_var)
    
    if (input$explicativeX_var %in% colnames(sdata())) {
      determine_explicativeX_variable(sdata()[, input$explicativeX_var])
    }
  })
  
  # Nouveau menu déroulant pour sélectionner le test statistique. 
  output$statistical_test_dropdown <- shiny::renderUI({
    shiny::req(input$expliquéeY_var, input$explicativeX_var)
    
    if (input$explicativeX_var == "reference value") {
      explicativeX_var <- "valeur de référence"
    } else {
      explicativeX_var <- sdata()[, input$explicativeX_var]
    }
    test <- SélectionTestStatistiques(sdata()[, input$expliquéeY_var], explicativeX_var)
    test_options <- c(test)
    shinyWidgets::pickerInput("statistical_test", "Choose statistical test", choices = test_options)
  })
  
  # Afficher l'histogramme de la variable Y sélectionnée.
output$expliquéeY_var_histogramme <- shiny::renderPlot({
    shiny::req(sdata(), input$expliquéeY_var)
    créer_expliquéeY_variable_histogramme(sdata()[, input$expliquéeY_var])
})

  # 4.Exporter les tests statistiques
output$test_report <- shiny::renderPrint({
  result <- perform_statistical_test(sdata(), input)
  if (!is.null(result)) result
})
}

```
Commandes spécifiques à flexdashboard
===============

L'intégration sous flexdashboard s'est révélée être plus simple que d'autres packages de template, car elle est dédiée aux rapports interactifs. 

Ainsi, flexdashboard s'ajoute à Rmarkdown, et il a été plutôt simple à prendre en main. Ainsi, il existe uniquement des commandes de mise en page qui diffèrent de Rmarkdown: 
-la série de signes d'égalités ================ permettent notamment de créer une nouvelle page
-les commentaires ##si storyboard accordés peuvente permettre de créer un menu déroulant à côté.

Exporter sous GIT
===============================
```{r}


```


Conclusion :
===============


Ainsi, pour conclure, cette application de tests statistiques, avec sélection automatique de tests paramétriques ou non paramétriques, permet donc d'avoir un calcul rapide du "bon" test statistique, et notamment ceux qui sont les moins courants. 

Ainsi, cela peut constituer un bon outil pour les personnes ayant des bases de données complexes à gérer. 

De plus, la construction de ce code, ainsi que des rapports interactifs, a été challengeante, notamment en termes de création de syntaxe, ce qui m'a permis de renforcer mes compétences dans la gestion de ce type d'erreurs. 

De plus, cela m'a permis également de parfaire mes connaissances dans des tests statistiques, souvent peu utilisés. 

Documentations 
==================
Pour flexdashboard : le tutoriel de Rstudio. 
https://rstudio.github.io/flexdashboard/articles/using.html#multiple-pages 
Pour R shiny 

Difficultés
==================

1.Pour Shiny, la compréhension de l'interface utilsisatuer a pu être compliquée. En effet, je ne comprenais pas forcément pourquoi on devait utiliser des commandes spécifiques à shiny, par exemple Renderplot. 
En fait, cela sert à dimenssionner correctement le graphique afin qu'il puisse s'afficher de la manière la plus agréable possible et peut se modifier automatiquement lors d'une autre sélection. 

rmarkdown::render(input = "Diaporama Projet Rshiny Final.Rmd", output_format = "html_document")

